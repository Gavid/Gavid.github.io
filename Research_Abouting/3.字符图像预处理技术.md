@[TOC](字符图像预处理技术)
**字符图像预处理技术**
> 字符识别是将写在纸张上的字符,经过扫描变为模拟信号,再经模数变换变为数字信
> 号输入计算机。由于纸张的厚薄、光洁度、书写质量等会造成计算机读取的字符变形,
> 加上扫描、输入过程中不可避免的存在噪声,从而会给实际识别造成干扰。因此在识别
> 前要对输入的图像进行预处理。
# 1. 图像灰度化
* 图像按色彩类型分为彩色图像、单色图像或称灰度图像。大多数图像是用32位RGB格式表示的,在RGB真彩色图像中,每个像素由相应于红、绿、蓝的3个不同的值组成当然彩色图像还可以表示成HSL,HSV,HSI等模式。而灰度图像是彩色图像的一个分量之一,一般是8bit的,每个像素用(0,255)表示。只有0和1(或0和255)二值表示的灰度图我们称之为二值图。为了保留更多的图像信息,减小目测结果的误差,将采集的RGB模式的彩色图像转化为灰度图像，以利于待识别图像的进一步处理。
* 将彩色图像转化为灰度图像的方法：
	* 第一种方法：求出每个像素点的R,G,B三个分量的平均值,然后将这个平均值赋予给这个像素的三个分量。
	* 第二种方法是根据YUV的颜色空间中,Y的分量的物理意义是点的亮度,由该值反映亮度等级,根据RGB和YUV颜色空间的变化关系可建立亮度Y与R,G,B三个颜色分量的对应:Y=0.3R+0.59G+0.11B,以这个亮度值表达图像的灰度值。
# 2. 图像二值化
* 二值化就是将灰度图像g(i,j)进行二值化处理,将图像上的点的灰度置为0或255,使整个图像呈现出明显的黑白效果,且二值化图像仍可以反映图像整体和局部特征。对图像进行二值化,需要选择合适的阈值,同时为了得到理想的二值图像,一般采用封闭、连通的边界。由于字符笔画内部有均匀一致的灰度值,使用阈值法就可以得到比较好的分割效果。字符灰度图像g(i,j)中灰度小于阈值T的像素被判定为字符笔画,灰度值置为0。否则这些像素点被认为是背景,其灰度值用255表示。
* 将灰度图像进行二值化的处理方法：
	* 整体阈值法
	* 局部阈值法
	* 动态阈值法
* 所谓的阈值法：事先设定一个阈值T，在对所有像素进行操作此阈值T都保持不变，阈值T可以通过灰度直方图得出。
![灰度双峰直方图](https://img-blog.csdnimg.cn/20190929154529369.png)
图中两个波峰分别为字符笔画和背景部分，波谷为该图像的整体阈值T。目标灰度与背景灰度有明显的差距时采用整体阈值法可以达到很好的二值化效果，但是若输入的图像的目标灰度和背景灰度差距不大或者光照不均匀时，采用 此方法就不能得到较好的效果。
# 3. 平滑去噪
* 数字图像的噪声主要来自于图像的获取阶段。噪声对于图像的预处理非常重要，它会影响图像处理的输入、采集、处理各个环节和识别结果的全过程。特别是图像的输入、采集的噪声是十分关键的问题。如果输入不良伴有较大的噪声,滤波去噪后不能达到理想效果，将必然的严重影响处理的全过程甚至识别结果。噪声去除已经成为图像处理极其重要的步骤，然而现在还没有一个通用的滤波去噪方法对所有的图片适用，一般的图像预处理必须根据实际情况选择不同滤波去噪方法进行比较，最后得出最佳的滤波去噪方法。
* 滤波去噪的方法大体可以分为两大类：频域滤波和空间域滤波。频域滤波一般采用的方法是将空间图像采用快速傅里叶变换转换成频域信息，然后再采用信号处理的滤波方法进行滤波，滤波处理后再通过傅里叶逆变换成空间图像信息，从而达到去噪效果。但是由于频域滤波需要频域转换后再采用滤波器滤波，其实现起来较为复杂，效率也相对较低，而空间域滤波方法速度较快、实现简单、效果很好，因此现在很多研究者中都采用空间域滤波方法对数字图像进行滤波。常用的滤波方法如下:
	* 邻域平滑法:利用某- -像素及其邻域像素灰度的平均值作为该中心像素的灰度值，该方法简单但缺点明显，它使图像边界变得模糊。
	* 保存边界平滑法:以某一像素作为正方形邻域的中心点，然后选择若干模板，计算每个模板所含像素灰度的方差，计算方差最小的模板所含像素灰度的平均值作为该像素的灰度值。该方法既可以达到去噪的目的，又可以同时保存边界，但计算量庞大。
	* 中值滤波算法:中值滤波算法的思想是首先确定-一个以某像素为中心点的邻域，一般为方形邻域，然后将邻域中的各个像素的灰度值进行排序，取其中间值作为中心点像素灰度的新值。这里的邻域- -般可以称为窗口。当窗口在图像中上下左右进行移动后，利用中值滤波算法就可以很好地对图像进行去噪处理，同时使得图像更加平滑。
# 4. 字符分割
* 由于考虑到字符识别的时长及识别准确率，若直接识别一连串字符则效率较低，因此要将输入的一连串字符进行分割，分割成单个的字符再进行识别。
* 现有字符分割的方法可分为三类：
	* 第一类是基于统计方法的切分，这种方法适用于字符宽度相差不大的场合。它根据字符的总体统计分布特征，确定字符之间的界线。进行分割判别时以字符的平均字宽作为辅助判别，统计分布特征的代表性和稳定性对切分的正确性及收敛性起很重要的作用;
	* 第二类是基于结构的切分，即从字与字之间以及字符本身的结构入手，综合分析、寻找切分的规则:
	* 第三类是基于识别的切分方法，即在实际切分前，对各种可能存在的切分结果进行识别，通过对识别结果的判别来选择最终的切分点。
# 5. 字符图像的归一化和细化
> 由于书写的随意性，分割后的字符图像的大小不尽相同，各笔画的密度也不尽相同，因此要对图像进行归一化和细化处理。
## 字符图像的归一化
* 归一化是指将不同大小的字符图像映射到固定大小的字符点阵中来满足识别的需要。归一化可分为线性归一和非线性归一两种方法。
	* 线性归一化就是将文字图像按比例线性放大或缩小为同一尺寸，算法简单，失真较小，但是无法调整手写字符的中心位置和笔画密度。
	* 非线性归一化强调按照手写字符的特征分布来处理，调整字符的中心位置，削弱那些偏长、偏粗的笔画段，增强一些较短、较细的笔画，或者是突出字符笔画密集的区域，压缩笔画分散的区域。常见的实现方法有:基于字符点密度的方法，基于字符笔画交叉点密度的方法等。
# 字符图像的细化
* 对字符图像细化处理的要求：
	* 要保留原有笔画的连续性，不能由于细化造成笔画断开
	* 要细化为单线，即笔画宽度只有一个像素
	* 细化后的骨架应尽量是原来笔画的中心线
	* 要保持文字原有特征，既不要增加，也不要丢失。
* 细化的算法很多，但大多数细化算法都是从字符的边界开始逐层移去黑点，称之为**脱壳算法**。
* 图像的细化算法目前依据是否使用迭代运算可将其分成两类:
	* 第一类是非迭代算法，一次即产生骨架，如基于距离变换的方法、游程长度编码细化等。
	* 第二类是迭代算法，即重复删除图像边缘满足一定条件的像素，最终得到单像素宽骨架。这类方法依据其检查像素的方法又可再分成串行算法和并行算法。
		* 在串行算法中，是否删除像素在每次迭代的执行中是顺序固定的，它不仅仅取决于前次迭代的结果，也取决于本次迭代中已处理过像素的分布情况，
		* 在并行算法中，像素的删除与否与像素在图像中的顺序无关，仅取决于前次迭代的结果。
	* 常用的有Hilditch细化算法、Deutsch 细化算法、Pavlidis异步细化算法等。  Hilditch细化采用串行处理方式，Deutsch 细化采用并行处理方式，Pavlidis 异步细化则采用并行和串行混合处理方式。